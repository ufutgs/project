package sutd.compiler.simp.ir

import sutd.compiler.simp.ir.PseudoAssembly.*
import sutd.compiler.simp.ir.CFG.*
import scala.annotation.tailrec



/**
  * This module contains the implementation of dominator tree, and dominance  frontier utils
  *  1. dominator tree
  *  2. construct a dominator tree from a CFG (generated from a PA program)
  *  3. construct a dominance frontier table
  */

object DF {

    enum DomTree {
        case Empty
        case Node(l:Label, children:List[DomTree])
    }

    /*
        Dominator tree construction algorithm.
        We do not follow the standard naive algorithm nor the semi-dominator tree approach
        The CFGs generated in our context are "structured", i.e. 
            1. branches and loops are generated by structured statement such as if-else and while. 
            2. there is only one exit point

        Terminology 
            1. successor, the next vertex in the graph,
            1. descendant, successor via transitivity
            1. child, the child node in the dominiator tree 


        The algorithm starts from vertex 0 which is the starting statement.
        Given vertex n in Graph G, 
        case 1: n has only 1 successor m in the CFG
            we create Node(n, List(t)), where t is generated recurssively using m against (G - {n})
        case 2: n has 2 successors m and k, m and k share some common nearest descendant j in (G - {n})
            (given two common descendant, j and l, j is nearer than l if j < l, 
                since we generate the labels by following the sequential structure of the program)
            we create Node(n, List(s,t)) 
                where s is generated recursively using m against (G - {n, j})
                and t is generated recursively using k against (G - {n, j})
            this case is to handle the structure generated by if-else
                n 
                /\
               m  k
               |  |
                \/
                j
        case 3: n has 2 successor m and k, m and k share no common descendant in (G - {n})
             ->n
            / / \
           | m   k
           | |
           \ / 
           we create Node(n, List(s,t)) 
              where s is generated recursively using m against (G - {n})
              and t is generated recursively using k against (G - {n})
          Note that it is not possible for k to loop back to n as n is removed from G when constructing t.
        case 4: n has no successor, return Node(n, Nil)
        
        What about other case where n has more than 2 successors? 
        not possible, our maximal munch algo guarantees there is an ending vertex 
        for each block (as the endThen and endElse goto)
    */

    /**
      * remove a vertex v from the graph g
      *
      * @param g - the graph
      * @param v - the vertex to be removed
      * @return a new graph same as g without v and its edges.
      */
    def remove(g:CFG, v:Label):CFG = g.filter( p => p match {
        case (src,dsts) => src != v
    }).toList.map(p => p match {
        case (src,dsts) => (src, dsts.filter( dst => dst != v))
    }).toMap

    import DomTree.*

    def buildDomTree(g:CFG, n:Label):Either[String, DomTree] = successors(g, n) match {
        case Nil =>  Right(Node(n, Nil)) // case 4
        case List(m) => for {
            // case 1
            t <- buildDomTree(remove(g, n), m)
        } yield Node(n, List(t))
        case List(m,k) => {
            val g1 = remove(g, n)
            val desc_m = descendants(g1, m)
            val desc_k = descendants(g1, k)
            val common = desc_m.intersect(desc_k) // possible optimization, we only need the first one.
            common.toList.sorted match {
                case j::xs => { // case 2
                    val g2 = remove(g1, j)
                    for {
                        s <- buildDomTree(g2, m)
                        t <- buildDomTree(g2, k)
                    } yield Node(n, List(s,t))
                }
                case Nil => for {  // case 3
                    s <- buildDomTree(g1, m)
                    t <- buildDomTree(g1, k)
                } yield Node(n, List(s,t))
            }
        }
        case otherwise => Left(s"buildDomTree failed. There are 3 successors for label ${n}")
    }


    /**
      * returns the list of labels of x's children in dom tree dt
      *
      * @param x
      * @param dt
      * @return
      */
    def childOf(x:Label, dt:DomTree):List[Label] = dt match {
        case Empty => Nil 
        case Node(l, children) if l == x => children.flatMap( t => t match {
            case Node(m, _) => List(m)
            case Empty => Nil
        }) 
        case Node(l, children) => children.foldLeft(List():List[Label])( (acc, ch) => {
            acc ++ childOf(x, ch)
        }) 
    }

    /**
      * checks whether label y is a immediate child of x in dom tree dt
      *
      * @param y
      * @param x
      * @param dt
      * @return
      */
    def isChildOf(y:Label, x:Label, dt:DomTree):Boolean = childOf(x,dt).contains(y)
    


    type DFTable = Map[Label, List[Label]] // maping label to its dominance frontier



    /**
      * 1. For each vertex v by traversing the dominator tree bottom up: 
      *  i. compute df_local(v, G)
      *  ii. compute U_u\inchild(v,T) df_up(u,G), which can be looked up from the a memoization table. 
      *  iii. save df(v,G)=dflocal(v,G) union U_u\in child(v,T) in the memoizationtable.
    */
    
    /**
      * post order traversal of a dom tree
      *  it is in order traversal then reverse
      *
      * @param dt
      * @return
      */
    def postOrderTrav(dt:DomTree):List[Label] = inOrderTrav(dt).reverse

    def inOrderTrav(dt:DomTree):List[Label] = dt match {
        case Empty => Nil
        case Node(l, children) => l :: children.flatMap(ch => inOrderTrav(ch))
    }

    // df local implementation from cytron's lemma 2
    // Task 1.1 TODO 
    def dfLocal(x:Label, dt:DomTree, g:CFG):List[Label] = {
        @tailrec
        def dfLocalHelper(x:Label,dt:DomTree,l:List[Label],result:List[Label]):List[Label] =l match {
                case Nil => result
                case r::rest => isChildOf(r,x,dt) match {
                    case false => dfLocalHelper(x,dt,rest,r::result)
                    case true => dfLocalHelper(x,dt,rest,result)
                }
            }
        CFG.successors(g,x) match{
        case Nil => Nil
        case vs => dfLocalHelper(x,dt,vs,Nil)
    }
}

    /**
      * Build dominance frontier table 
      *
      * @param dt
      * @param g
      * @return
      */
    def buildDFT(dt:DomTree, g:CFG):DFTable = {
        val emptyDFT:DFTable = Map()
  
        def go(acc:DFTable, x:Label):DFTable = {
            val df_local = dfLocal(x, dt, g)
            // Task 1.1 TODO 
            def dfUp(u:Label):List[Label] =  acc.get(u) match{
                case None => Nil
                case Some(vs) => vs.flatMap(k => dfUpHelper(k,x,dt))
            }

            def dfUpHelper(x:Label,u:Label,dt:DomTree): List[Label] = isChildOf(x,u,dt) match{
                case false => List[Label](x)
                case true => Nil
            }
            
            
            val df_up = childOf(x,dt).flatMap(u => dfUp(u))
            acc + (x -> (df_local ++ df_up))
        }
        postOrderTrav(dt).foldLeft(emptyDFT)(go)
    }


    /**
      * compute the DF+ of a list of vertexes vs
      *
      * @param dft
      * @param vs
      * @return
      */
    
    def dfPlus(dft:DFTable, vs:List[Label]):List[Label] = {
        def go(curr:Set[Label]):Set[Label] = {
            val next = curr.flatMap( v => dft.get(v) match {
                case None => Set()
                case Some(vs) => vs.toSet
            })
            if (next == curr) { curr } else { go(next) } 
        }
        go(vs.toSet).toList
    }

}